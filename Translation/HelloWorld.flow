import runtime;
import lingo/pegcode/driver;
import string;
import ds/array;
import ds/arrayutils;
import sys/system;

sumF(a : int, b : int) -> int { a + b; }
subF(a : int, b : int) -> int { a - b; }
prodF(a : int, b : int) -> int { a * b; }
divF(a : int, b : int) -> int { a / b; }

ArExp ::= ArOp, ArInt, ArVar;
ArOp : (op : (int, int) -> int, l : ArExp, r : ArExp, c : string);
ArInt : (val : int);
ArVar : (word : string);

RpnEl ::= RpnOp, RpnVal;
RpnVal : (val : int);
RpnOp : (op : (int, int) -> int, c : string);

variables : ref Tree<string, [int]> = ref TreeEmpty();

parse(str : string) -> Maybe<ArExp> {
    gram = "#include exp.lingo";
    parser = compilePegGrammar(gram);
    result = parsic3(parser, str, 
        SemanticActions(mergeTree(defaultPegActions.t,
            pairs2tree([
                Pair("sumOp", \s -> 
                    ArOp(sumF, s[0], s[1], "+")
                ),
                Pair("subOp", \s ->
                    ArOp(subF, s[0], s[1], "-")
                ),
                Pair("prodOp", \s ->
                    ArOp(prodF, s[0], s[1], "*")
                ),
                Pair("divOp", \s ->
                    ArOp(divF, s[0], s[1], "/")
                ),
                Pair("variable", \s ->
                    ArVar(s[0])
                ),
                Pair("assign", \s -> {
                    variables := mergeTree(^variables, makeTree1(s[0], [ar2i(s[1])]));
                    ArInt(ar2i(s[1]));
                })
            ])
        )), 
        ArInt(0)
    );
    if (result.third == "") Some(result.first) else None();
}

ar2i(a : ArExp) -> int {
    switch(a) {
        ArOp(func, first, second, c) : func(ar2i(first), ar2i(second));
        ArInt(value) : value;
        ArVar(word) : lastElement(getTreeArrayValue(^variables, word), 0);
    }
}

ar2s(a : ArExp) -> string {
    switch(a) {
        ArOp(func, first, second, c) : "(" + ar2s(first) + c + ar2s(second) + ")";
        ArInt(value) : i2s(value);
        ArVar(word) : word;
    }
}

deriv(a : ArExp, var : string) -> ArExp {
    result : ref ArExp = ref ArInt(0);
    switch(a) {
        ArOp(op, l, r, c) : {
            if (c == "+") {
                result := ArOp(op, deriv(l, var), deriv(r, var), c);
            } else if (c == "-") {
                result := ArOp(op, deriv(l, var), deriv(r, var), c);
            } else if (c == "*") {
                result := ArOp(sumF, ArOp(op, deriv(l, var), r, c), ArOp(op, l, deriv(r, var), c), "+");
            } else {
                result := ArOp(divF, 
                ArOp(subF, ArOp(prodF, deriv(l, var), r, "*"), ArOp(prodF, l, deriv(r, var), "*"), "-"), 
                ArOp(prodF, r, r, "*"), "/");
            }
        };
        ArInt(val) : result := ArInt(0);
        ArVar(word) : {
            if (word == var) {
                result := ArInt(1);
            } else {
                result := ArInt(0);
            }
        };
    }
    simplify(^result);
}

simplify(a : ArExp) -> ArExp {
    switch(a : ArExp) {
        ArOp(op, l, r, c) : {
            ll = simplify(l);
            rr = simplify(r);
            if (c == "+" || c == "-") {
                 if (ll == ArInt(0)) {
                     rr;
                 } else if (rr == ArInt(0)) {
                     ll;
                 } else {
                     ArOp(op, ll, rr, c);
                 }
            } else {
                if (ll == ArInt(1)) {
                    rr;
                } else if (rr == ArInt(1)) {
                    ll;
                } else if (ll == ArInt(0) || rr == ArInt(0)) {
                    ArInt(0);
                } else {
                    ArOp(op, ll, rr, c);
                }
            }
        };
        ArInt(val) : a;
        ArVar(word) : a;
    }
}

main() {
    expr = "(((2 * x) + 2) / y)";
    a = parse(expr);
    switch(a : Maybe<ArExp>) {
        None() : println("parse error");
        Some(arExp) : {
            der : ArExp = deriv(arExp, "x");
            println(ar2s(der));
        };
    }

    // from exp.lingo (boolsheet)
    // assignment = " "* letter+ $w " "*"="" "* exp:val " "*";" {assign($w, :val)};

    // code : [string] = [
    //     "x = 2;",
    //     "y = 4;",
    //     "seven = 7;",
    //     "five = 5;",
    //     "result = (y * (x + ((seven * 2) - five)));"
    // ];
    // iter(code, \s -> {
    //     a = parse(s);
    //     switch(a : Maybe<ArExp>) {
    //         None() : println("no return");
    //         Some(arExp) : println(arExp);
    //     }
    // });
    
    // expr = "( 4 * (2 + ( ( 7 * 2 ) - 5 ) ) )";
    // a = parse(expr);
    // switch(a : Maybe<ArExp>) {
    //     None() : println("Parsing error (runtime)");
    //     Some(arExp) : {
    //         println("Arithmetical expression : " + expr);
    //         print("Parsed into : ");
    //         println(arExp);
    //         rpn = ar2rpn(arExp);
    //         rpnVal = rpn2i(rpn);
    //         println("Reverse Polish notation : " + rpn2s(rpn));
    //         switch(rpnVal) {
    //             None() : println("Incorrect expression");
    //             Some(val) : println("Its value : " + i2s(val));
    //         }
    //         print("Reverse Polish notation converted back to arithmetical expression : ");
    //         println(rpn2ar(rpn));
    //     }
    // };
}

// graveyard

// ar2rpn(a : ArExp) -> [RpnEl] {
//     switch(a) {
//         ArOp(func, first, second, c) : concat(ar2rpn(first), concat(ar2rpn(second), [RpnOp(func, c)]));
//         ArInt(value) : [RpnVal(value)];
//     }
// }

// rpn2i(a : [RpnEl]) -> Maybe<int> {
//     stack : ref [int] = ref [];
//     iteri(a, \i, elem -> {
//         switch(elem) {
//             RpnVal(val) : refArrayPush(stack, val);
//             RpnOp(op, c) : {
//                 fir : int = lastElement(^stack, 0);
//                 stack := removeLastElement(^stack);
//                 sec : int = lastElement(^stack, 0);
//                 stack := removeLastElement(^stack);
//                 refArrayPush(stack, op(sec, fir));
//             };
//         }
//     });
//     if (length(^stack) == 0) {
//         None();
//     } else {
//         Some(^stack[0]);
//     }
// }

// rpn2ar(r : [RpnEl]) -> ArExp {
//     stack : ref [ArExp] = ref [];
//     iteri(r, \i, elem -> {
//         switch(elem) {
//             RpnOp(op, c): {
//                 fir : ArExp = lastElement(^stack, ArInt(0));
//                 stack := removeLastElement(^stack);
//                 sec : ArExp = lastElement(^stack, ArInt(0));
//                 stack := removeLastElement(^stack);
//                 refArrayPush(stack, ArOp(op, sec, fir, c));
//             };
//             RpnVal(val): refArrayPush(stack, ArInt(val));
//         };
//     });
//     ^stack[0];
// }

// getChar(r : RpnEl) -> string {
//     switch(r) {
//         RpnVal(val) : i2s(val);
//         RpnOp(op, c) : c;
//     }
// }

// rpn2s(a : [RpnEl]) -> string {
//     result : string = fold(a, "", \result, element -> {
//         switch(element) {
//             RpnVal(value) : result + i2s(value) + " ";
//             RpnOp(op, c) : result + c + " ";
//         }
//     });
//     result;
// }
